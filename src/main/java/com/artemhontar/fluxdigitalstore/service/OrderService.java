package com.artemhontar.fluxdigitalstore.service;

import com.artemhontar.fluxdigitalstore.api.model.User.UserOrderRequest;
import com.artemhontar.fluxdigitalstore.exception.*;
import com.artemhontar.fluxdigitalstore.model.LocalUser;
import com.artemhontar.fluxdigitalstore.model.OrderItem;
import com.artemhontar.fluxdigitalstore.model.UserOrder;
import com.artemhontar.fluxdigitalstore.model.enums.ORDER_STATUS;
import com.artemhontar.fluxdigitalstore.repo.OrderRepo;
import com.artemhontar.fluxdigitalstore.repo.UserRepo;
import com.artemhontar.fluxdigitalstore.service.User.AuthenticationService;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j; // Required import for logging
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Service class responsible for handling all aspects of user orders,
 * including creation, payment processing, inventory reservation, and dispatch.
 */
@Service
@Slf4j // Add Lombok logging annotation
public class OrderService {


    private final FinanceService financeService;
    private final AuthenticationService authenticationService;
    private final OrderRepo orderRepo;
    private final InventoryService inventoryService;


    public OrderService(FinanceService financeService, AuthenticationService authenticationService, OrderRepo orderRepo, InventoryService inventoryService, UserRepo userRepo) {
        this.financeService = financeService;
        this.authenticationService = authenticationService;
        this.orderRepo = orderRepo;
        this.inventoryService = inventoryService;
    }

    /**
     * Creates a new order by processing payment, generating the order record,
     * and reserving stock.
     *
     * @param orderRequest The request containing order details, items, and user information.
     * @return The newly created and processed UserOrder with status PROCESSING.
     * @throws PaymentFailedException If the financial checkout fails.
     * @throws NotFoundException      If the current user cannot be authenticated.
     * @throws NotEnoughStock         If stock reservation for any item fails.
     * @throws RuntimeException       For unexpected errors, resulting in a CANCELLED order.
     */
    public UserOrder createOrder(UserOrderRequest orderRequest) {
        log.info("Starting new order creation process.");
        String paymentID = null;
        UserOrder order = null;
        try {
            // Step 1: Process Payment
            log.debug("Step 1: Processing payment.");
            paymentID = financeService.checkout(orderRequest);

            // Step 2: Generate and Save Order (Status: PENDING_RESERVATION)
            log.debug("Step 2: Generating and saving order with status PENDING_RESERVATION.");
            order = generateOrder(orderRequest, paymentID, ORDER_STATUS.PENDING_RESERVATION);

            // Step 3: Reserve Stock (Moves stock from warehouse to on-hold)
            log.debug("Step 3: Reserving stock for Order ID: {}", order.getId());
            reserveOrder(order);

            // Step 4: Finalize Status to PROCESSING
            log.debug("Step 4: Finalizing order status to PROCESSING for Order ID: {}", order.getId());
            order.setStatus(ORDER_STATUS.PROCESSING);
            UserOrder processedOrder = orderRepo.save(order);
            log.info("Order ID {} created and moved to status PROCESSING.", processedOrder.getId());
            return processedOrder;

        } catch (FinancialOperationException e) {
            log.error("Order creation failed: Payment failed.", e);
            throw new PaymentFailedException("Payment failed!");
        } catch (NotFoundException e) {
            log.error("Order creation failed: User not authenticated.", e);
            throw e;
        } catch (NotEnoughStock e) {
            // Rollback: Stock reservation failed. Cancel the order record.
            if (order != null) {
                order.setStatus(ORDER_STATUS.CANCELLED);
                orderRepo.save(order);
                log.warn("Order ID {} cancelled due to insufficient stock.", order.getId());
            }
            throw e;
        } catch (Exception e) {
            // General error handling: Cancel the order record.
            if (order != null) {
                order.setStatus(ORDER_STATUS.CANCELLED);
                orderRepo.save(order);
                log.error("Order ID {} cancelled due to an unexpected error.", order.getId(), e);
            }
            throw new RuntimeException("An unexpected error occurred during order creation.", e);
        }
    }

    /**
     * Helper method to generate the initial UserOrder entity and persist it.
     * It relies on the currently authenticated user.
     *
     * @param orderRequest  The request containing order items.
     * @param paymentID     The unique ID generated by the payment service.
     * @param initialStatus The starting status (e.g., PENDING_RESERVATION).
     * @return The persisted UserOrder entity.
     * @throws NotFoundException If the current user is not logged in.
     */
    private UserOrder generateOrder(UserOrderRequest orderRequest, String paymentID, ORDER_STATUS initialStatus) {
        log.debug("Generating order entity with payment ID: {} and status: {}", paymentID, initialStatus);
        Optional<LocalUser> opUser = authenticationService.tryGetCurrentUser();
        if (opUser.isPresent()) {
            LocalUser user = opUser.get();
            UserOrder order = new UserOrder();
            List<OrderItem> items = new ArrayList<>();

            // Establish bidirectional relationship for persistence
            for (OrderItem item : orderRequest.getOrderItems()) {
                item.setUserOrder(order);
                items.add(item);
            }

            order.setOrderItems(items);
            order.setDate(new Timestamp(System.currentTimeMillis()));
            order.setStatus(initialStatus);
            order.setPaymentId(paymentID);
            order.setLocalUser(user);

            UserOrder savedOrder = orderRepo.save(order);
            log.info("Initial order entity saved for User ID: {} with Order ID: {}", user.getId(), savedOrder.getId());
            return savedOrder;
        }
        log.error("Failed to generate order: User not authenticated.");
        throw new NotFoundException("User is not logged in!");
    }

    /**
     * Reserves the inventory stock for all items in a given order.
     * This moves stock from warehouse to on-hold status.
     *
     * @param order The UserOrder whose items need reservation.
     * @throws IllegalStateException If the order contains no items.
     * @throws NotEnoughStock        If stock is insufficient for any item.
     */
    private void reserveOrder(UserOrder order) {
        log.debug("Starting stock reservation for Order ID: {}", order.getId());
        if (order.getOrderItems().isEmpty()) {
            log.error("Reservation failed for Order ID {}: No items found.", order.getId());
            throw new IllegalStateException("Cannot reserve stock for an order with no items.");
        }

        for (OrderItem item : order.getOrderItems()) {
            log.debug("Reserving {} units of Product ID {} for Order ID {}", item.getQuantity(), item.getProductId(), order.getId());
            inventoryService.reserveStock(item.getProductId(), item.getQuantity(), order.getId());
        }
        log.debug("Stock reservation completed for Order ID: {}", order.getId());
    }

    /**
     * Dispatches a processed order. This method is typically called by a background system
     * or a warehouse management interface. Includes an authorization check to ensure the
     * current user is either the order owner or an administrator.
     *
     * @param orderID The ID of the UserOrder to dispatch.
     * @return The updated UserOrder with status DISPATCHED.
     * @throws IllegalArgumentException    If the order is not found.
     * @throws IllegalStateException       If the order is not in PROCESSING status or if a stock inconsistency is detected.
     * @throws UnauthorizedAccessException If the authenticated user is not an Admin or the owner of the order.
     */
    @Transactional
    public UserOrder dispatchOrder(Long orderID) {
        log.info("Attempting to dispatch Order ID: {}", orderID);
        UserOrder order = orderRepo.findById(orderID)
                .orElseThrow(() -> {
                    log.warn("Dispatch failed: Order ID {} not found.", orderID);
                    return new IllegalArgumentException("Order is not found with ID: " + orderID);
                });

        log.debug("Order found. Checking authorization for User ID: {}", order.getLocalUser().getId());
        final boolean isAdminBypass = authenticationService.isAdmin();

        if (!isAdminBypass) {
            Optional<LocalUser> opCurrentUser = authenticationService.tryGetCurrentUser();

            if (opCurrentUser.isEmpty()) {
                log.warn("Dispatch failed for Order ID {}: Authentication required.", orderID);
                throw new UnauthorizedAccessException("Authentication required to dispatch an order.");
            }

            Long currentUserId = opCurrentUser.get().getId();
            Long orderOwnerId = order.getLocalUser().getId();

            if (!currentUserId.equals(orderOwnerId)) {
                log.warn("Dispatch failed for Order ID {}: Unauthorized access attempt by User ID {}.", orderID, currentUserId);
                throw new UnauthorizedAccessException("User is not authorized to dispatch this order. Ownership check failed.");
            }
        }

        if (order.getStatus() != ORDER_STATUS.PROCESSING) {
            log.warn("Dispatch failed for Order ID {}: Status is not PROCESSING (Current Status: {}).", orderID, order.getStatus());
            throw new IllegalStateException("Order status is not PROCESSING. Cannot dispatch.");
        }

        try {
            log.debug("Starting item-level dispatch for Order ID: {}", orderID);
            List<OrderItem> dispatchedItems = dispatchReservedItems(order);

            order.setOrderItems(dispatchedItems);
            order.setDate(new Timestamp(System.currentTimeMillis()));
            order.setStatus(ORDER_STATUS.DISPATCHED);
            UserOrder dispatchedOrder = orderRepo.save(order);
            log.info("Order ID {} successfully dispatched.", orderID);
            return dispatchedOrder;

        } catch (NotEnoughStock e) {
            log.error("Dispatch failed for Order ID {}: Stock inconsistency detected.", orderID, e);
            throw new IllegalStateException("Failed to dispatch order items. Stock inconsistency detected.", e);
        }
    }

    /**
     * Handles the actual dispatch of reserved items by calling the InventoryService.
     * This method depletes the ON_HOLD stock for each item.
     *
     * @param order The UserOrder to dispatch.
     * @return The list of OrderItems updated with dispatch status.
     * @throws IllegalStateException If order items or delivery address are missing.
     * @throws NotEnoughStock        If the inventory's on-hold stock is insufficient (critical error).
     * @throws InventoryNotFound     If the inventory record is missing (critical error).
     */
    private List<OrderItem> dispatchReservedItems(UserOrder order) {
        log.debug("Processing reserved items for dispatch, Order ID: {}", order.getId());
        if (order.getOrderItems() == null || order.getOrderItems().isEmpty()) {
            log.error("Dispatch failed: Order Items are empty for order ID: {}", order.getId());
            throw new IllegalStateException("Order Items are empty for order ID: " + order.getId());
        }

        if (order.getDeliveryAddress() == null) {
            log.error("Dispatch failed: Order is missing a delivery address for Order ID: {}", order.getId());
            throw new IllegalStateException("Order is missing a delivery address for dispatch.");
        }

        Long deliveryAddressId = order.getDeliveryAddress().getId();

        for (OrderItem current : order.getOrderItems()) {
            try {
                // Dispatch stock (decreases onHoldStock)
                log.debug("Dispatching {} units of Product ID {} from ON_HOLD stock.", current.getQuantity(), current.getProductId());
                inventoryService.dispatchStock(
                        current.getProductId(),
                        current.getQuantity(),
                        order.getId(),
                        deliveryAddressId
                );

                // Mark the item as dispatched
                current.setDispatched(true);
                current.setDateDispatched(new Timestamp(System.currentTimeMillis()));
                log.debug("Item Product ID {} marked as dispatched.", current.getProductId());

            } catch (NotEnoughStock e) {
                log.error("Critical failure during dispatch for Order ID {}: ON_HOLD stock insufficient for Product ID {}.", order.getId(), current.getProductId(), e);
                throw e;
            } catch (InventoryNotFound e) {
                log.error("Critical failure during dispatch for Order ID {}: Inventory record not found for Product ID {}.", order.getId(), current.getProductId(), e);
                throw new IllegalStateException("Inventory record not found during dispatch, but was present during reservation.", e);
            }
        }
        return order.getOrderItems();
    }

    /**
     * Retrieves all orders placed by the currently authenticated user.
     *
     * @return A list of UserOrder entities belonging to the current user.
     * @throws NotFoundException If no authenticated user is found in the security context.
     */
    public List<UserOrder> getOrdersForCurrentUser() {
        log.info("Attempting to retrieve orders for the currently authenticated user.");
        // Use AuthenticationService to find the logged-in user
        Optional<LocalUser> opUser = authenticationService.tryGetCurrentUser();

        if (opUser.isPresent()) {
            LocalUser user = opUser.get();
            log.debug("Fetching orders for User ID: {}", user.getId());
            // Assuming OrderRepo has a method to find orders by LocalUser entity
            List<UserOrder> orders = orderRepo.findByLocalUser(user);
            log.info("Retrieved {} orders for User ID: {}", orders.size(), user.getId());
            return orders;
        }

        // If no user is found, throw a relevant exception
        log.warn("Failed to retrieve orders: No authenticated user found.");
        throw new NotFoundException("No authenticated user found to retrieve orders.");
    }
}