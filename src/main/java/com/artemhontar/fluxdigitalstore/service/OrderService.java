package com.artemhontar.fluxdigitalstore.service;

import com.artemhontar.fluxdigitalstore.api.model.User.UserOrderRequest;
import com.artemhontar.fluxdigitalstore.exception.*;
import com.artemhontar.fluxdigitalstore.model.LocalUser;
import com.artemhontar.fluxdigitalstore.model.OrderItem;
import com.artemhontar.fluxdigitalstore.model.UserOrder;
import com.artemhontar.fluxdigitalstore.model.enums.ORDER_STATUS;
import com.artemhontar.fluxdigitalstore.repo.OrderRepo;
import com.artemhontar.fluxdigitalstore.repo.UserRepo;
import com.artemhontar.fluxdigitalstore.service.User.AuthenticationService;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Service class responsible for handling all aspects of user orders,
 * including creation, payment processing, inventory reservation, and dispatch.
 */
@Service
public class OrderService {


    private final FinanceService financeService;
    private final AuthenticationService authenticationService;
    private final OrderRepo orderRepo;
    private final InventoryService inventoryService;


    public OrderService(FinanceService financeService, AuthenticationService authenticationService, OrderRepo orderRepo, InventoryService inventoryService, UserRepo userRepo) {
        this.financeService = financeService;
        this.authenticationService = authenticationService;
        this.orderRepo = orderRepo;
        this.inventoryService = inventoryService;
    }

    /**
     * Creates a new order by processing payment, generating the order record,
     * and reserving stock.
     *
     * @param orderRequest The request containing order details, items, and user information.
     * @return The newly created and processed UserOrder with status PROCESSING.
     * @throws PaymentFailedException If the financial checkout fails.
     * @throws UserNotExistsException If the current user cannot be authenticated.
     * @throws NotEnoughStock         If stock reservation for any item fails.
     * @throws RuntimeException       For unexpected errors, resulting in a CANCELLED order.
     */
    public UserOrder createOrder(UserOrderRequest orderRequest) {
        String paymentID = null;
        UserOrder order = null;
        try {
            // Step 1: Process Payment
            paymentID = financeService.checkout(orderRequest);

            // Step 2: Generate and Save Order (Status: PENDING_RESERVATION)
            order = generateOrder(orderRequest, paymentID, ORDER_STATUS.PENDING_RESERVATION);

            // Step 3: Reserve Stock (Moves stock from warehouse to on-hold)
            reserveOrder(order);

            // Step 4: Finalize Status to PROCESSING
            order.setStatus(ORDER_STATUS.PROCESSING);
            return orderRepo.save(order);

        } catch (FinancialOperationException e) {
            // Log payment failure details
            throw new PaymentFailedException("Payment failed!");
        } catch (UserNotExistsException e) {
            // Log user not found details
            throw e;
        } catch (NotEnoughStock e) {
            // Rollback: Stock reservation failed. Cancel the order record.
            if (order != null) {
                order.setStatus(ORDER_STATUS.CANCELLED);
                orderRepo.save(order);
            }
            throw e;
        } catch (Exception e) {
            // General error handling: Cancel the order record.
            if (order != null) {
                order.setStatus(ORDER_STATUS.CANCELLED);
                orderRepo.save(order);
            }
            throw new RuntimeException("An unexpected error occurred during order creation.", e);
        }
    }

    /**
     * Helper method to generate the initial UserOrder entity and persist it.
     * It relies on the currently authenticated user.
     *
     * @param orderRequest  The request containing order items.
     * @param paymentID     The unique ID generated by the payment service.
     * @param initialStatus The starting status (e.g., PENDING_RESERVATION).
     * @return The persisted UserOrder entity.
     * @throws UserNotExistsException If the current user is not logged in.
     */
    private UserOrder generateOrder(UserOrderRequest orderRequest, String paymentID, ORDER_STATUS initialStatus) {
        Optional<LocalUser> opUser = authenticationService.tryGetCurrentUser();
        if (opUser.isPresent()) {
            UserOrder order = new UserOrder();
            List<OrderItem> items = new ArrayList<>();

            // Establish bidirectional relationship for persistence
            for (OrderItem item : orderRequest.getOrderItems()) {
                item.setUserOrder(order);
                items.add(item);
            }

            order.setOrderItems(items);
            order.setDate(new Timestamp(System.currentTimeMillis()));
            order.setStatus(initialStatus);
            order.setPaymentId(paymentID);
            order.setLocalUser(opUser.get());

            return orderRepo.save(order);
        }
        throw new UserNotExistsException("User is not logged in!");
    }

    /**
     * Reserves the inventory stock for all items in a given order.
     * This moves stock from warehouse to on-hold status.
     *
     * @param order The UserOrder whose items need reservation.
     * @throws IllegalStateException If the order contains no items.
     * @throws NotEnoughStock        If stock is insufficient for any item.
     */
    private void reserveOrder(UserOrder order) {
        if (order.getOrderItems().isEmpty()) {
            throw new IllegalStateException("Cannot reserve stock for an order with no items.");
        }

        for (OrderItem item : order.getOrderItems()) {
            inventoryService.reserveStock(item.getProductId(), item.getQuantity(), order.getId());
        }
    }

    /**
     * Dispatches a processed order. This method is typically called by a background system
     * or a warehouse management interface. Includes an authorization check to ensure the
     * current user is either the order owner or an administrator.
     *
     * @param orderID The ID of the UserOrder to dispatch.
     * @return The updated UserOrder with status DISPATCHED.
     * @throws IllegalArgumentException    If the order is not found.
     * @throws IllegalStateException       If the order is not in PROCESSING status or if a stock inconsistency is detected.
     * @throws UnauthorizedAccessException If the authenticated user is not an Admin or the owner of the order.
     */
    @Transactional
    public UserOrder dispatchOrder(Long orderID) {

        UserOrder order = orderRepo.findById(orderID)
                .orElseThrow(() -> new IllegalArgumentException("Order is not found with ID: " + orderID));


        final boolean isAdminBypass = authenticationService.isAdmin();

        if (!isAdminBypass) {


            Optional<LocalUser> opCurrentUser = authenticationService.tryGetCurrentUser();

            if (opCurrentUser.isEmpty()) {
                throw new UnauthorizedAccessException("Authentication required to dispatch an order.");
            }

            Long currentUserId = opCurrentUser.get().getId();
            Long orderOwnerId = order.getUserId();

            if (!currentUserId.equals(orderOwnerId)) {
                throw new UnauthorizedAccessException("User is not authorized to dispatch this order. Ownership check failed.");
            }
        }


        if (order.getStatus() != ORDER_STATUS.PROCESSING) {
            throw new IllegalStateException("Order status is not PROCESSING. Cannot dispatch.");
        }

        try {
            List<OrderItem> dispatchedItems = dispatchReservedItems(order);

            order.setOrderItems(dispatchedItems);
            order.setDate(new Timestamp(System.currentTimeMillis()));
            order.setStatus(ORDER_STATUS.DISPATCHED);
            return orderRepo.save(order);

        } catch (NotEnoughStock e) {
            throw new IllegalStateException("Failed to dispatch order items. Stock inconsistency detected.", e);
        }
    }

    /**
     * Handles the actual dispatch of reserved items by calling the InventoryService.
     * This method depletes the ON_HOLD stock for each item.
     *
     * @param order The UserOrder to dispatch.
     * @return The list of OrderItems updated with dispatch status.
     * @throws IllegalStateException If order items or delivery address are missing.
     * @throws NotEnoughStock        If the inventory's on-hold stock is insufficient (critical error).
     * @throws InventoryNotFound     If the inventory record is missing (critical error).
     */
    private List<OrderItem> dispatchReservedItems(UserOrder order) {
        if (order.getOrderItems() == null || order.getOrderItems().isEmpty()) {
            throw new IllegalStateException("Order Items are empty for order ID: " + order.getId());
        }

        if (order.getDeliveryAddress() == null) {
            throw new IllegalStateException("Order is missing a delivery address for dispatch.");
        }

        Long deliveryAddressId = order.getDeliveryAddress().getId();

        for (OrderItem current : order.getOrderItems()) {
            try {
                // Dispatch stock (decreases onHoldStock)
                inventoryService.dispatchStock(
                        current.getProductId(),
                        current.getQuantity(),
                        order.getId(),
                        deliveryAddressId
                );

                // Mark the item as dispatched
                current.setDispatched(true);
                current.setDateDispatched(new Timestamp(System.currentTimeMillis()));

            } catch (NotEnoughStock e) {
                // Propagate exception to trigger rollback in dispatchOrder()
                throw e;
            } catch (InventoryNotFound e) {
                throw new IllegalStateException("Inventory record not found during dispatch, but was present during reservation.", e);
            }
        }
        return order.getOrderItems();
    }

    /**
     * Retrieves all orders placed by the currently authenticated user.
     *
     * @return A list of UserOrder entities belonging to the current user.
     * @throws UserNotExistsException If no authenticated user is found in the security context.
     */
    public List<UserOrder> getOrdersForCurrentUser() {
        // Use AuthenticationService to find the logged-in user
        Optional<LocalUser> opUser = authenticationService.tryGetCurrentUser();

        if (opUser.isPresent()) {
            LocalUser user = opUser.get();
            // Assuming OrderRepo has a method to find orders by LocalUser entity
            return orderRepo.findByLocalUser(user);
        }

        // If no user is found, throw a relevant exception
        throw new UserNotExistsException("No authenticated user found to retrieve orders.");
    }
}